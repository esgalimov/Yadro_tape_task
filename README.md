# Yadro TATLIN Data Services 
## Тестовое задание
Устройство хранения данных типа лента (Tape) предназначено для последовательной записи и чтения данных. Считывающая/записывающая магнитная головка неподвижна во время чтения и записи, а лента имеет возможность двигаться в обоих направлениях. Запись и чтение информации возможны в ячейку ленты, на которой в данный момент находится магнитная головка. Перемещения ленты – затратная по времени операция – лента не предназначена для произвольного доступа.

Имеется входная лента длины N (где N – велико), содержащая элементы типа integer (2^32). Имеется выходная лента такой же длины. Необходимо записать в выходную ленту отсортированные по возрастанию элементы с входной ленты. Есть ограничение по использованию оперативной памяти – не более M байт (M может быть < N, т.е. загрузить все данные с ленты в оперативную память не получится).

### Алгоритм
Требуется 2 временные ленты. 
1. Данные считываются с входной ленты в оперативную память, сортируются с помощью алгоритма quick sort
и полученные отсортированные подмассивы поочередно переписываются на временные ленты.

2. Когда все данные с ленты считаны, происходит обработка временных лент.
3. С обеих временных лент поочерёдно считываются данные.
4. При этом очередные данные с двух лент сравниваются между собой. По результатами сравнения на выходную ленту записывается меньший элемент из пары. Считывание и сравнение происходит только в пределах отсортированных подмассивов.
5. Если на одной из временных лент закончились элементы очередного подмассива, то с оставшейся ленты остаток подмассива просто переносится на выходную ленту.
6. Данные последовательно считываются с выходной ленты.
7. Пока последовательно считываемые данные представляют из себя упорядоченный подмассив, они переписываются на одну из временных лент.
8. Как только завершается очередной отсортированный подмассив (т.е. на выходной ленте встречается элемент, меньший чем предыдущий), и происходит переключение на другую временную ленту.

Повторяем пункты 2 - 8, пока не получим отсортированные данные на выходной ленте.

### Класс tape_t
Моделирует ленту посредством бинарного файла открытого на чтение и запись (используется std::fstream).
Конструкторы:
- **tape_t() = default**
- **tape_t(const std::string& filename, std::size_t sz)**

Методы:
- **void init_stream(const std::string& filename, std::size_t sz, bool trunc = true)** - служит для открытия нового файла ленты, параметр trunc отвечает за то, удалять содержимое файла при открытии или нет
- **void rewind_begin()** - перемотка ленты в начало
- **void rewind_end()** - перемотка ленты в конец
- **T read()** - чтение числа из ячейки
- **void write(T val)** - запись числа в ячейку
- **void shift_next()** - сдвиг на следующую ячейку
- **void shift_prev()** - сдвиг на предыдущую ячейку
- **std::size_t size()** - размер ленты в байтах
- **void save_pos()** - сохранение текущей позиции (в приватную переменную класса)
- **bool check_pos()** - проверка, что находимся на сохраненной позиции
- **bool is_end()** - проверка, что находимся в конце ленты (в конце ленты есть фиктивная ячейка, куда можно сдвинуться, но нельзя выполнить операции чтения и записи)
- **bool is_begin()** - проверка, что находимся в начале ленты

### Класс sorter_t
Реализует алгоритм сортировки

Конструктор:
- **sorter_t(const std::string& iname, const std::string& oname, cp::config_t config)** - открывает файлы лент (входной, выходной и врменных) и устанавливает настройки из структуры **config** (про нее далее)
Деструктор удаляет файлы временных лент.

Публичные методы:
- **void set_config(cp::config_t config)** - устанавливает новые ностройки
- **void set_files(const std::string& iname, const std::string& oname)** - открывает новые файлы лент (входной и выходной)
- **std::size_t sort()** - сортировка данных с входной ленты на выходную, возвращает посчитанное время (сложенное из всех операций сдвига, чтения/записи и перемотки)

### config.hpp и вспомогательные функции
структура config_t имеет следующие поля
- **tape_sz_** - размер ленты в байтах
- **ram_sz_** - размер оперативной памяти в байтах
- **rw_tm_** - время чтения записи в некоторых единицах времени
- **rewind_tm_** - время перемотки
- **shift_tm_** - время сдвига

Функции:
- **config_t parse_config(const std::string& filename)** - чтения конфигурации из файла filename
- **std::size_t parse_number(std::ifstream& input)** - вспомогательная функция для парсинга чисел из конфига
- **std::string read_to_binary(const std::string& filename)** - создание бинарного файла и чтение туда чисел из "человеко-читаемого" файла filename, возвращает имя бинарного файла
- **std::string get_output_bin(const std::string& filename)** - создание бинарного выходного файла (название создается из filename), возвращает имя бинарного файла
- **void write_output_numan_readable(const std::string& iname, const std::string& oname)** - вывод из бинарного файла iname чисел в "человеко-читаемом" формате в файл oname

### Установка и запуск
Установка
```
git clone https://github.com/esgalimov/Yadro_tape_task
cd Yadro_tape_task
```
Компиляция
```
cmake -B build
cd build
make
```
Запуск
```
./Yadro_tape_task [-nb] *input_path* *output_path* [*config_path*]
```
- Если передан флаг ```-nb``` (not binary), значит нужно передавать "человеко-читаемые" файлы, они будут преобразованы в бинарные,
будет выполнена сортировка и результаты будут в "человеко-читаемом" формате в файле ```*output_path*``` и в бинарном формате в ```*output_path*.bin```
- Если флаг не передан, то нужно подавать на вход бинарные файлы, результат будет в бинарном формате в ```*output_path*```
- ```[*config_path*]``` - необязательный параметр, по умолчанию будет взят конфиг из корневой папки проекта

Для запуска юнит-тестов
```